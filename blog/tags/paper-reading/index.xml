<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paper Reading on The Evening Paper</title>
    <link>https://millyz.github.io/blog/tags/paper-reading/</link>
    <description>Recent content in Paper Reading on The Evening Paper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 13 Feb 2019 10:50:14 +0800</lastBuildDate>
    
	<atom:link href="https://millyz.github.io/blog/tags/paper-reading/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A ZigZag-Decodable Code with the MDS Property for Distributed Storage Systems, ISIT13</title>
      <link>https://millyz.github.io/blog/posts/zzdc-isit13/</link>
      <pubDate>Wed, 13 Feb 2019 10:50:14 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/zzdc-isit13/</guid>
      <description>Summary This paper presents ZigZag-Decodable Code (ZD), a new vector code that has the MDS property. For data retrieval, only XOR operations are needed while for node failure, uncoded and exact repair can be performed. Note that uncoded repair means that a newcomer (to replace the failed node) can simply download data from d survivor nodes without any encoding/decoding operations. It allows fast encoding and decoding (operate over GF(2)) because it does not require a large finite-field size.</description>
    </item>
    
    <item>
      <title>SageDB:A Learned Database System, CIDR19</title>
      <link>https://millyz.github.io/blog/posts/sagedb-cidr19/</link>
      <pubDate>Tue, 12 Feb 2019 10:40:49 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/sagedb-cidr19/</guid>
      <description>The paper targets on the problem caused by the general design of modern data processing systems, which do not consider the characteristics of the particular application and data of the user. The main idea of SageDB is to design a highly specialized DB for an application through code synthesis and machine learning. Though previous work has explored the use of machine learning in DB design, the authors argue that the learned components can fully replace core components of a database system such as index structures, sorting algorithm, or even query executor.</description>
    </item>
    
    <item>
      <title>Cassandra - A Decentralized Structured Storage System</title>
      <link>https://millyz.github.io/blog/posts/cassandra/</link>
      <pubDate>Mon, 28 Jan 2019 17:21:43 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/cassandra/</guid>
      <description>Cassandra is a distributed storage system for structured data spread out across many commodity servers, while providing high availability, durability, and scalability. It achieves high write throughput and read efficiency.
System architecture  Partition, Membership, and Scalability  Cassandra partitions data across the cluster using consistent hashing (an order preserving hash function). Each data item identified by a key is assigned to a node, which is the coordinator of for this key.</description>
    </item>
    
    <item>
      <title>An Analysis of Network-Partitioning Failures in Cloud Systems</title>
      <link>https://millyz.github.io/blog/posts/neat-osdi18/</link>
      <pubDate>Fri, 07 Dec 2018 13:19:26 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/neat-osdi18/</guid>
      <description>This paper studies 136 system failures attributed to network-partitioning faults from 25 widely used distributed systems. They find that the majority of the failures leads to catastrophic effects and can be easily detected by isolating a single node. The challenging is that the number of test cases that one must consider is extremely large. Then they identify ordering, timing and network fault characteristics to simplify testing. They built NEAT, a testing framework that simplifies the coordination of multiple clients and can inject different types of network-partitioning faults.</description>
    </item>
    
    <item>
      <title>Spiffy: Enabling File-System Aware Storage Applications, FAST &#39;18</title>
      <link>https://millyz.github.io/blog/posts/spiffy-fast18/</link>
      <pubDate>Wed, 05 Dec 2018 09:27:56 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/spiffy-fast18/</guid>
      <description>This paper presents Spiffy, an annotation language for specifying the on-disk format of a file system. Spiffy allows file-system developers to unambiguously specify the physical layout of the file system where the annotations handle low-level details. Then, the annotation is compiled to generate a Spiffy library that provides interfaces for type-safe parsing, traversal and update of file system metadata. This generic library simplify the development of applications that work across different file system, which reduces the burden of developing file-system aware storage applications.</description>
    </item>
    
    <item>
      <title>Overload Control for Scaling WeChat Microservices, SoCC &#39;18</title>
      <link>https://millyz.github.io/blog/posts/dagor-socc18/</link>
      <pubDate>Mon, 03 Dec 2018 17:21:30 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/dagor-socc18/</guid>
      <description>This paper presents the microservice architecture and overload control at WeChat. We can take a look how such a massive application runs internally, which is the point attracting me most. This paper is easy to follow and understand. In conclusion, the technique introduced in this paper seems straightforward and practical.
The motivation of this paper is quite strong and very clear. &amp;ldquo;Workload handled by the WeChat backend is always varying over time, and the fluctuation pattern differs among diverse situations&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Clay codes: Moulding MDS Codes to Yield an MSR Code, FAST &#39;18</title>
      <link>https://millyz.github.io/blog/posts/claycodes-fast18/</link>
      <pubDate>Mon, 29 Oct 2018 19:00:00 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/claycodes-fast18/</guid>
      <description>The title attracts me at the first sight. How do the authors switch a MDS code to a MSR code though they belong to different classes of erasure codes from my understanding? After reading the abstract, a big question mark arises over my head as the properties of this code seems rather promising. This new code, termed as Clay codes (short for Coupled-Layer), achieves the following properties:
 Low storage overhead; Optimal in repair bandwidth, sub-packetization level and disk I/O; Uniform repair performance of data and parity nodes; Support for both single and multiple-node repairs, while permitting faster and more efficient repair.</description>
    </item>
    
  </channel>
</rss>