<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<link rel="apple-touch-icon" sizes="180x180" href="/blog/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon-16x16.png">
	<link rel="manifest" href="/blog/site.webmanifest">
	<link rel="mask-icon" href="/blog/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/blog/favicon.ico">
	<title>Clay codes: Moulding MDS Codes to Yield an MSR Code, FAST &#39;18</title>
	<link rel="stylesheet" href="/blog/css/style.min.bde2f5cd3b77a52d8db26f638dfed4b52085d3ea252fdf5746658b9883382220.css" integrity="sha256-veL1zTt3pS2Nsm9jjf7UtSCF0+olL99XRmWLmIM4IiA=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://millyz.github.io/blog/">The Evening Paper</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="/blog/posts/">Posts</a>
					<a href="/blog/about/">About</a>
				</nav>
			</div>
			<div class="hdr-right">
				<div class="hdr-icons">
					<span class="hide-in-mobile"><a href="https://github.com/millyz" target="_blank" rel="noopener"><span class="screen-reader-text">github</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span>
					<button id="menu-btn" class="hdr-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
				</div>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast" style="display: none;">
		<ul>
			<li><a href="/blog/posts/">Posts</a></li>
			<li><a href="/blog/about/">About</a></li>
		</ul>
	</div>

	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Oct 29, 2018</span></div>
				<h1>Clay codes: Moulding MDS Codes to Yield an MSR Code, FAST &#39;18</h1>
			</header>
			<div class="content">
				

<p>The title attracts me at the first sight. How do the authors switch a MDS code to
a MSR code though they belong to different classes of erasure codes from my
understanding? After reading the abstract, a big question mark arises over my
head as the properties of this code seems rather promising. This new code,
termed as <em>Clay codes</em> (short for Coupled-Layer), achieves the following
properties:</p>

<ol>
<li>Low storage overhead;</li>
<li>Optimal in repair bandwidth, sub-packetization level and disk I/O;</li>
<li>Uniform repair performance of data and parity nodes;</li>
<li>Support for both single and multiple-node repairs, while permitting faster
and more efficient repair.</li>
</ol>

<p>We can look at how Clay codes offer these advantages one by one later.  Before
going into the details of Clay codes, we first review the motivation and
challenges of this work.  In my opinion, they really try to solve
a challenging and practical problem. Now more and more distributed storage
systems employ erasure coding to protect data against failures. And one class of
widely-used erasure codes is <em>Maximum Distance Separable (MDS) codes</em>, e.g.,
Reed-Solomon codes. However, MDS codes incur high repair bandwidth while they
offer minimum storage overhead. Therefore, another class of codes named
<em>Minimum Storage Regenerating (MSR) codes</em> is proposed to minimize the repair
bandwidth cost while keeping low storage overhead and tolerating faults as MDS
codes. But the authors think the current MSR codes are not practical enough to
adopt in real-world storage systems. They consider the following points:</p>

<ul>
<li>Complex computation, e.g., nccloud;</li>
<li>Non-uniform repair for different types of node failures, e.g., HashTag;</li>
<li>Tolerate limited number of failures, e.g., Butterfly;</li>
<li>Uncommon construction of erasure codes, e.g., PM-RMT, Butterfly.</li>
</ul>

<p>Well, Clay codes do beat the existing MSR codes from the following
perspectives. Actually this paper can be considered as an extension of their
previous paper. The key idea of Clay codes is &ldquo;Clay codes are constructed by
placing any MDS code in multiple layers and performing pair-wise coupling
across layers.&rdquo; No magic in computer science but math exists. They add
additional computation to encoding/decoding such that minimum data can complete
the recovery as MSR codes. During encoding, Clay codes convert to uncoupled
code via pairwise reverse transform (PRT), perform MDS encoding, then turn back
to coupled codes via pairwise forward transform (PFT). For single-node
recovery, Clay codes first perform PRT to obtain the uncoupled code, MDS
decoding, and then compute the coupled element. Briefly speaking, the less
repair bandwidth cost derives from the coupling (or spreading data across
layers), i.e., any two sub-chunks out of {U, U∗, C, C∗} can be computed from
remaining two (Q: why not one-to-one?).  Detailed explanation can be found in
the slides.</p>

<p>They implement Clay codes on Ceph, which is the first vector codes running on
Ceph. In the evaluation, they compare Clay codes with RS codes, which I think
can be better if considering other MSR codes. Hope I can implement it by myself
someday and continue to compare it with other erasure codes.</p>

<h2 id="references">References:</h2>

<ul>
<li><a href="https://www.usenix.org/system/files/conference/fast18/fast18-vajha.pdf" target="_blank">Paper</a></li>
<li><a href="https://www.usenix.org/sites/default/files/conference/protected-files/fast18_slides_vajha.pdf" target="_blank">Authors&rsquo;
slides</a></li>
</ul>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://millyz.github.io/blog/tags/paper-reading">Paper Reading</a></span><span class="tag"><a href="https://millyz.github.io/blog/tags/erasure-coding">Erasure coding</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>497 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2018-10-29 19:00 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://millyz.github.io/blog/posts/dagor-socc18/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Overload Control for Scaling WeChat Microservices, SoCC &#39;18</span>
			</a>
		</div>
	</main>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

	<script>let haveHeader = true;</script>

	<script src="/blog/js/main.min.00689ba18bbf9422fda222b02b555f01d54bfbb9b6d02f9bcffad67bdb2ff2cd.js" integrity="sha256-AGiboYu/lCL9oiKwK1VfAdVL+7m20C+bz/rWe9sv8s0="></script>
	
</body>

</html>