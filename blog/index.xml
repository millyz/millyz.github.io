<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Evening Paper</title>
    <link>https://millyz.github.io/blog/</link>
    <description>Recent content on The Evening Paper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 03 Dec 2018 17:21:30 +0800</lastBuildDate>
    
	<atom:link href="https://millyz.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Overload Control for Scaling WeChat Microservices, SoCC &#39;18</title>
      <link>https://millyz.github.io/blog/posts/dagor-socc18/</link>
      <pubDate>Mon, 03 Dec 2018 17:21:30 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/dagor-socc18/</guid>
      <description>This paper presents the microservice architecture and overload control at WeChat. We can take a look how such a massive application runs internally, which is the point attracting me most. This paper is easy to follow and understand. In conclusion, the technique introduced in this paper seems straightforward and practical.
The motivation of this paper is quite strong and very clear. &amp;ldquo;Workload handled by the WeChat backend is always varying over time, and the fluctuation pattern differs among diverse situations&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://millyz.github.io/blog/about/</link>
      <pubDate>Sun, 25 Nov 2018 14:46:47 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/about/</guid>
      <description>Welcome to Milly&amp;rsquo;s blog. I&amp;rsquo;d like to share my learning here from three perspectives:
 Paper readings Programming Technology  If you have any comments, please contact me at millyz0204@gmail.com. : )</description>
    </item>
    
    <item>
      <title>Clay codes: Moulding MDS Codes to Yield an MSR Code, FAST &#39;18</title>
      <link>https://millyz.github.io/blog/posts/claycodes-fast18/</link>
      <pubDate>Mon, 29 Oct 2018 19:00:00 +0800</pubDate>
      
      <guid>https://millyz.github.io/blog/posts/claycodes-fast18/</guid>
      <description>The title attracts me at the first sight. How do the authors switch a MDS code to a MSR code though they belong to different classes of erasure codes from my understanding? After reading the abstract, a big question mark arises over my head as the properties of this code seems rather promising. This new code, termed as Clay codes (short for Coupled-Layer), achieves the following properties:
 Low storage overhead; Optimal in repair bandwidth, sub-packetization level and disk I/O; Uniform repair performance of data and parity nodes; Support for both single and multiple-node repairs, while permitting faster and more efficient repair.</description>
    </item>
    
  </channel>
</rss>